// services/appointment.service.js
const appointmentRepo = require('../repositories/appointment.repository');
const rpcClient = require('../utils/rpcClient');
const redis = require('../utils/redis.client');

// T·∫°o m·ªõi appointment (ch∆∞a chi·∫øm slot)
exports.createHold = async (data, userIdFromToken) => {
  const { patientId, serviceId, scheduleId, slotId, preferredDentistId, channel} = data;

  // 0. Ki·ªÉm tra patientId b√™n Auth/User Service
  const patient = await rpcClient.request('auth_queue', {
    action: 'getUserById',
    payload: { userId: patientId }
  });
  if (!patient || patient.role !== 'patient') {
    throw new Error('Invalid patientId or user is not a patient');
  }

  // 1. Ki·ªÉm tra serviceId trong Redis
  const servicesCache = await redis.get('services_cache');
  if (!servicesCache) throw new Error('Services cache not found');
  const services = JSON.parse(servicesCache);
  const selectedService = services.find(s => s._id === serviceId);
  if (!selectedService) throw new Error('Invalid serviceId');

  // 2. Ki·ªÉm tra scheduleId v√† dentist trong Schedule Service
  const schedule = await rpcClient.request('schedule_queue', {
    action: 'getScheduleById',
    payload: { scheduleId }
  });
  if (!schedule || schedule.status !== 'active') {
    throw new Error('Schedule not found or inactive');
  }

  // N·∫øu c√≥ preferredDentistId, ki·ªÉm tra dentist c√≥ trong schedule kh√¥ng
  if (preferredDentistId && !schedule.dentistIds.includes(preferredDentistId)) {
    throw new Error('Preferred dentist is not available in this schedule');
  }

  // 3. Check slot c√≥ thu·ªôc schedule v√† tr·∫°ng th√°i l√† available
  const slot = await rpcClient.request('schedule_queue', {
    action: 'getSlotById',
    payload: { slotId }
  });
  if (!slot || slot.scheduleId !== scheduleId) {
    throw new Error('Slot does not belong to the schedule');
  }
  // Ki·ªÉm tra tr·∫°ng th√°i slot
  if (slot.status === 'confirmed') {
    throw new Error('Slot is already confirmed');
  }

  if (slot.status === 'reserved') {
    throw new Error('Slot is currently reserved by another appointment');
  }

  if (slot.status !== 'available') {
    throw new Error(`Slot is not available (status: ${slot.status})`);
  }

  // 4. X√°c ƒë·ªãnh bookedBy
  const bookedBy = patientId || userIdFromToken;
  if (!bookedBy) throw new Error('Cannot determine who booked the appointment');

  // 5. L∆∞u booking t·∫°m v√†o Redis v·ªõi TTL 10 ph√∫t
  const holdKey = `appointment_hold:${slotId}`;
  await redis.set(holdKey, JSON.stringify({
    ...data,
    bookedBy,
    status: 'booked', 

    createdAt: new Date()
  }), 'EX', 10 * 60);
   

  


  // üîπ C·∫≠p nh·∫≠t tr·∫°ng th√°i slot sang "reserved"
  try {
    await rpcClient.request('schedule_queue', {
      action: 'reserved',
      payload: { slotId }
    });
    console.log(`‚úÖ Slot ${slotId} status updated to reserved`);
  } catch (err) {
    console.error(`‚ùå Failed to set slot ${slotId} to reserved:`, err.message);
  }

  // üîπ G·ªçi sang Payment Service ƒë·ªÉ t·∫°o payment t·∫°m
  const payment = await rpcClient.request('payment_queue', {
    action: 'createTemporaryPayment',
    payload: {
      appointmentHoldKey: holdKey,
      slotId,
      amount: selectedService.price,  // gi√° d·ªãch v·ª•
      method: channel || 'vnpay'
    }
  });


  console.log(`‚úÖ Appointment hold created for slot ${slotId}`);

  // T·∫°o timeout ƒë·ªÉ release slot t·ª± ƒë·ªông khi hold h·∫øt h·∫°n
  // T·∫°o timeout ƒë·ªÉ x·ª≠ l√Ω sau 10 ph√∫t
  setTimeout(async () => {
    const holdDataRaw = await redis.get(holdKey);
    if (!holdDataRaw) {
      // N·∫øu key ƒë√£ h·∫øt h·∫°n (Redis auto x√≥a) th√¨ release slot
      try {
        const released = await rpcClient.request('schedule_queue', {
          action: 'releaseSlot',
          payload: { slotId }
        });
        console.log(`üîÑ Slot ${slotId} automatically released after hold expired`, released);
      } catch (err) {
        console.error(`Failed to release slot ${slotId}:`, err.message);
      }
      return;
    }

    // N·∫øu Redis c√≤n t·ªìn t·∫°i (nghƒ©a l√† v·∫´n ch∆∞a expire sau 10 ph√∫t)
    const holdData = JSON.parse(holdDataRaw);

    if (holdData.status === 'confirmed') {
      // N·∫øu appointment ƒë√£ confirm (do payment confirm RPC), th√¨ push v√†o DB
      try {
        await exports.confirm(slotId);
        console.log(`‚úÖ Auto-confirmed appointment for slot ${slotId} after payment`);
      } catch (err) {
        console.error(`‚ùå Failed to auto-confirm appointment for slot ${slotId}:`, err.message);
      }
    } else {
      // N·∫øu ch∆∞a confirmed th√¨ release slot
      try {
        await rpcClient.request('schedule_queue', {
          action: 'releaseSlot',
          payload: { slotId }
        });
        await redis.del(holdKey);
        console.log(`üîÑ Slot ${slotId} released after hold expired without confirmed`);
      } catch (err) {
        console.error(`‚ùå Failed to release slot ${slotId}:`, err.message);
      }
    }
  }, 10 * 60 * 1000); // 10 ph√∫t

  return {
      message: 'Slot hold created for 10 minutes',
      holdKey,
      slotId: slot._id
};
};



exports.confirm = async (holdKey) => {
  console.log('‚úÖ Confirm appointment triggered for holdKey:', holdKey);

  // 1Ô∏è‚É£ L·∫•y d·ªØ li·ªáu appointment t·∫°m t·ª´ Redis
  const keyStr = typeof holdKey === 'string' ? holdKey : holdKey.holdKey;
  const holdDataRaw = await redis.get(keyStr);

  console.log('holdDataRaw:', holdDataRaw);

  if (!holdDataRaw) {
    throw new Error('Hold expired or not found');
  }

  const holdData = JSON.parse(holdDataRaw);

  // 2Ô∏è‚É£ Ki·ªÉm tra tr·∫°ng th√°i payment ƒë√£ confirm ch∆∞a
  if (holdData.status !== 'confirmed') {
    throw new Error('Payment not confirmed yet, cannot create appointment');
  }

  // 3Ô∏è‚É£ T·∫°o appointment th·∫≠t trong DB
  const appointment = await appointmentRepo.create({
    ...holdData,
    status: 'confirmed'
  });

  // 4Ô∏è‚É£ C·∫≠p nh·∫≠t tr·∫°ng th√°i slot sang "confirmed" trong Schedule Service
  await rpcClient.request('schedule_queue', {
    action: 'confirmed',
    payload: { slotId: holdData.slotId }
  });

  // 5Ô∏è‚É£ G·ª≠i appointmentId sang Schedule Service ƒë·ªÉ c·∫≠p nh·∫≠t slot
  await rpcClient.request('schedule_queue', {
    action: 'appointmentId',
    payload: {
      slotId: holdData.slotId,
      appointmentId: appointment._id
    }
  });

  // 6Ô∏è‚É£ T·∫°o Invoice trong Invoice Service qua RabbitMQ
  try {
  const invoiceResponse = await rpcClient.request('invoice_queue', {
    action: 'createInvoiceFromAppointment',
    payload: {
      patientId: appointment.patientId,
      appointmentId: appointment._id,
      services: appointment.serviceId.map(id => ({
        serviceId: id,
        quantity: 1,          // m·∫∑c ƒë·ªãnh 1
        note: `Service from appointment ${appointment._id}`
      })),
      method: holdData.paymentMethod || 'cash',
      notes: `Invoice for appointment ${appointment._id}`
    }
  });



  console.log('‚úÖ Invoice created from appointment:', invoiceResponse);
} catch (err) {
  console.error('‚ùå Failed to create invoice from appointment:', err);
  // c√≥ th·ªÉ rollback ho·∫∑c ch·ªâ log
}


  // 7Ô∏è‚É£ X√≥a appointment t·∫°m trong Redis
  await redis.del(keyStr);

  console.log(`‚úÖ Appointment confirmed and created for slot ${holdData.slotId}`);
  return appointment;
};





// C·∫≠p nh·∫≠t appointment (c√≥ x·ª≠ l√Ω ƒë·ªïi slot)
exports.update = async (id, data) => {
  const appointment = await appointmentRepo.findById(id);
  if (!appointment) throw new Error('Appointment not found');

  // Ch·ªâ x·ª≠ l√Ω khi ƒë·ªïi slot
  if (data.slotId && data.slotId !== appointment.slotId) {

    if (appointment.status !== 'confirmed') {
      throw new Error('Only confirmed appointments can be updated');
    }

    // --- Tr·∫£ slot c≈© ---
    await rpcClient.request('schedule_queue', {
      action: 'updateSlot',
      payload: {
        slotId: appointment.slotId,
        update: { status: 'available', appointmentId: null }
      }
    });

    // --- Ki·ªÉm tra slot m·ªõi ---
    const slot = await rpcClient.request('schedule_queue', {
      action: 'getSlotById',
      payload: { slotId: data.slotId }
    });

    if (!slot || slot.status !== 'available') {
      throw new Error('New slot is not available');
    }

    // --- Chi·∫øm slot m·ªõi ---
    await rpcClient.request('schedule_queue', {
      action: 'updateSlot',
      payload: {
        slotId: data.slotId,
        update: { status: 'confirmed', appointmentId: appointment._id }
      }
    });
  }

  return appointmentRepo.updateById(id, data);
};

// Hu·ª∑ appointment
exports.cancelHold = async (slotId) => {
  const holdKey = `appointment_hold:${slotId}`;
  const holdDataRaw = await redis.get(holdKey);
  if (!holdDataRaw) throw new Error('Hold not found');

  const holdData = JSON.parse(holdDataRaw);

  // Tr·∫£ slot v·ªÅ available
  await rpcClient.request('schedule_queue', {
    action: 'releaseSlot',
    payload: { slotId }
  });

  // Xo√° Redis
  await redis.del(holdKey);

  console.log(`‚ùå Hold cancelled for slot ${slotId}`);
  return { message: 'Hold cancelled' };
};

// Check-in
exports.checkIn = async (id) => {
  // 1Ô∏è‚É£ L·∫•y appointment t·ª´ DB
  const appointment = await appointmentRepo.findById(id);
  if (!appointment) throw new Error('Appointment not found');

  if (appointment.status !== 'confirmed') {
    throw new Error('Only confirmed appointments can be checked-in');
  }

  // 2Ô∏è‚É£ C·∫≠p nh·∫≠t tr·∫°ng th√°i trong DB
  const updated = await appointmentRepo.updateById(id, { status: 'checked-in' });

  // 3Ô∏è‚É£ G·ªçi Record Service qua RPC (thay v√¨ publish tr·ª±c ti·∫øp b·∫±ng amqp)
  try {
     const recordResponse = await rpcClient.request('record_queue', {
    action: 'createRecord',
    payload: {
      appointmentId: updated._id,
      patientId: updated.patientId._id || updated.patientId,
      dentistId: updated.preferredDentistId || null,
      serviceId: (updated.serviceId || []).map(s => s.toString()), // ‚úÖ ƒë·∫£m b·∫£o array ObjectId string
      type: updated.type,
      notes: updated.notes || ""
      }
    });


    console.log("üì§ Check-in RPC request sent to record_queue:", recordResponse);
  } catch (err) {
    console.error("‚ùå Failed to create record on check-in:", err);
  }

  return updated;
};


// Ho√†n th√†nh
exports.complete = (id) => {
  return appointmentRepo.updateById(id, { status: 'completed' });
};

// T√¨m ki·∫øm
exports.search = (filter) => {
  return appointmentRepo.search(filter);
};


